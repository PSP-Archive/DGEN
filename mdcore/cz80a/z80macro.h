#ifndef CZ80_MACRO_H
#define CZ80_MACRO_H

#define VERBOSE 0
#if VERBOSE
#define LOG(x)	logerror x
#else
#define LOG(x)
#endif
#undef VERBOSE

/***************************************************************
 * Check IRQ
 ***************************************************************/

#define CHECK_INT													\
	if (zIFF1)										   				\
	{																\
		cpu->Halted = 0;								 			\
		zIFF1 = zIFF2 = 0;							   				\
		cpu->IRQVector = cpu->Interrupt_Callback(0);  				\
														 			\
		if (zIM == 2)												\
		{															\
			PUSH_16(zRealPC)						 				\
			cpu->IRQVector = (cpu->IRQVector & 0xff) | (zI << 8);	\
			READ_WORD(cpu->IRQVector, PC)				 			\
			SET_PC(PC)												\
			cpu->ExtraCycles += 17;					  				\
		}															\
		else if (zIM == 1)											\
		{															\
			PUSH_16(zRealPC)										\
			SET_PC(0x38)											\
			cpu->ExtraCycles += 13;									\
		}															\
		else														\
		{															\
			LOG(("Z80 IM0 $%04x\n", cpu->IRQVector));				\
			switch (cpu->IRQVector & 0xff0000)						\
			{														\
			case 0xcd0000:	/* call */								\
				PUSH_16(zRealPC)									\
				PC = cpu->IRQVector & 0xffff;						\
				SET_PC(PC)											\
				cpu->ExtraCycles += 19;								\
				break;												\
																	\
			case 0xc30000:	/* jump */								\
				PC = cpu->IRQVector & 0xffff;						\
				SET_PC(PC)											\
				cpu->ExtraCycles += 12;								\
				break;												\
																	\
			default:												\
				PUSH_16(zRealPC)									\
				PC = cpu->IRQVector & 0x38;							\
				SET_PC(PC)											\
				cpu->ExtraCycles += 13;								\
				break;												\
			}														\
		}															\
	}



/***************************************************************
 * Main OP code
 ***************************************************************/

/***************************************************************
 * POP
 ***************************************************************/
#define POP(r16) POP_16(r16)

/***************************************************************
 * PUSH
 ***************************************************************/
#define PUSH(r16) PUSH_16(r16)

/***************************************************************
 * JP
 ***************************************************************/
#define JP														\
{																\
	PC = GET_WORD;												\
	SET_PC(PC)													\
}

/***************************************************************
 * JP_COND
 ***************************************************************/
#define JP_COND(cond)											\
	if (cond)													\
	{															\
		JP														\
		NEXT_EX													\
	}															\
	else zPC += 2;

/***************************************************************
 * JR
 ***************************************************************/
#define JR														\
{																\
	PC = zPC + FETCH_BYTE_S;									\
	SET_PC(PC)													\
}

/***************************************************************
 * JR_COND
 ***************************************************************/
#define JR_COND(cond)											\
	if (cond)													\
	{															\
		JR														\
		NEXT_EX													\
	}															\
	else zPC++;

/***************************************************************
 * CALL
 ***************************************************************/
#define CALL													\
{																\
	FETCH_WORD(PC);												\
	PUSH_16(zRealPC);											\
	SET_PC(PC);													\
}

/***************************************************************
 * CALL_COND
 ***************************************************************/
#define CALL_COND(cond)											\
	if (cond)													\
	{															\
		CALL													\
		NEXT_EX													\
	}															\
	else zPC += 2;

/***************************************************************
 * RET
 ***************************************************************/
#define _RET													\
{																\
	POP_16(PC);													\
	SET_PC(PC);													\
}

/***************************************************************
 * RET_COND
 ***************************************************************/
#define RET_COND(cond)											\
	if (cond)													\
	{															\
		RET														\
		NEXT_EX													\
	}

/***************************************************************
 * RST
 ***************************************************************/
#define RST(addr)												\
{																\
	PUSH_16(zRealPC)											\
	SET_PC(addr)												\
}

/***************************************************************
 * RLCA
 ***************************************************************/
#define RLCA													\
	zA = (zA << 1) | (zA >> 7);									\
	zF = (zF & (SF | ZF | PF)) | (zA & (YF | XF | CF));

/***************************************************************
 * RRCA
 ***************************************************************/
#define RRCA													\
	zF = (zF & (SF | ZF | PF)) | (zA & CF);						\
	zA = (zA >> 1) | (zA << 7);									\
	zF |= (zA & (YF | XF));

/***************************************************************
 * RLA
 ***************************************************************/
#define RLA														\
{																\
	u8 r = (zA << 1) | (zF & CF);								\
	u8 c = (zA & 0x80) ? CF : 0;								\
	zF = (zF & (SF | ZF | PF)) | c | (r & (YF | XF));			\
	zA = r;														\
}

/***************************************************************
 * RRA
 ***************************************************************/
#define RRA														\
{																\
	u8 r = (zA >> 1) | (zF << 7);								\
	u8 c = (zA & 0x01) ? CF : 0;								\
	zF = (zF & (SF | ZF | PF)) | c | (r & (YF | XF));			\
	zA = r;														\
}

/***************************************************************
 * EX   r16,r16
 ***************************************************************/
#define EX(a, b)												\
{																\
	val = a; a = b; b = val;									\
}

/***************************************************************
 * EX   (SP),r16
 ***************************************************************/
#define EXSP(r16)												\
{																\
	val = r16;													\
	READ_WORD(zSP, r16)											\
	WRITE_WORD(zSP, val)										\
}

/***************************************************************
 * INC  n
 ***************************************************************/
#define INC(n)													\
{																\
	n = (n + 1) & 0xff;											\
	zF = (zF & CF) | SZHV_inc[n];								\
}

/***************************************************************
 * DEC  n
 ***************************************************************/
#define DEC(n)													\
{																\
	n = (n - 1) & 0xff;											\
	zF = (zF & CF) | SZHV_inc[n];								\
}

/***************************************************************
 * DAA
 ***************************************************************/
#define DAA														\
{																\
	u8 cf, nf, hf, lo, hi, diff;								\
	cf = zF & CF;												\
	nf = zF & NF;												\
	hf = zF & HF;												\
	lo = zA & 15;												\
	hi = zA / 16;												\
																\
	if (cf)														\
	{															\
		diff = (lo <= 9 && !hf) ? 0x60 : 0x66;					\
	}															\
	else														\
	{															\
		if (lo >= 10)											\
		{														\
			diff = hi <= 8 ? 0x06 : 0x66;						\
		}														\
		else													\
		{														\
			if (hi >= 10)										\
			{													\
				diff = hf ? 0x66 : 0x60;						\
			}													\
			else												\
			{													\
				diff = hf ? 0x06 : 0x00;						\
			}													\
		}														\
	}															\
	if (nf) zA -= diff;											\
	else zA += diff;											\
																\
	zF = SZP[zA] | (zF & NF);									\
	if (cf || (lo <= 9 ? hi >= 10 : hi >= 9)) zF |= CF;			\
	if (nf ? hf && lo <= 5 : lo >= 10)	zF |= HF;				\
}

/***************************************************************
 * CPL
 ***************************************************************/
#define CPL														\
{																\
	zA ^= 0xff;													\
	zF = (zF & (SF | ZF | PF | CF))| HF | NF | (zA & (YF | XF));\
}

/***************************************************************
 * SCF
 ***************************************************************/
#define SCF														\
{																\
	zF = (zF & (SF | ZF | PF)) | CF | (zA & (YF | XF));			\
}

/***************************************************************
 * CCF
 ***************************************************************/
#define CCF														\
{																\
	zF = ((zF & (SF | ZF | PF | CF)) | ((zF & CF) << 4)			\
		| (zA & (YF | XF))) ^ CF;								\
}

/***************************************************************
 * AND  n
 ***************************************************************/
#define AND(n)													\
	zA &= n;													\
	zF = SZP[zA] | HF;

/***************************************************************
 * OR   n
 ***************************************************************/
#define OR(n)													\
	zA |= n;													\
	zF = SZP[zA];

/***************************************************************
 * XOR  n
 ***************************************************************/
#define XOR(n)													\
	zA ^= n;													\
	zF = SZP[zA];

/***************************************************************
 * ADD  A,n
 ***************************************************************/
#define ADD(n)													\
{																\
	u32 v = n;													\
	u32 r = zA + v;												\
	zF = SZ[(u8)r] | ((r >> 8) & CF) |							\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA ^ 0x80) & (v ^ r) & 0x80) >> 5);				\
	zA = (u8)r;													\
}

/***************************************************************
 * ADC  A,n
 ***************************************************************/
#define ADC(n)													\
{																\
	u32 v = n;													\
	u32 r = zA + v + (zF & CF);									\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) |						\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA ^ 0x80) & (v ^ r) & 0x80) >> 5);				\
	zA = r;														\
}

/***************************************************************
 * SUB  n
 ***************************************************************/
#define SUB(n)													\
{																\
	u32 v = n;													\
	u32 r = zA - v;												\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r;														\
}

/***************************************************************
 * SBC  A,n
 ***************************************************************/
#define SBC(n)													\
{																\
	u32 v = n;													\
	u32 r = zA - v - (zF & CF);									\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r;														\
}

/***************************************************************
 * CP   n
 ***************************************************************/
#define CP(n)													\
{																\
	u32 v = n;													\
	u32 r = zA - v;												\
	zF = (SZ[r & 0xff] & (SF | ZF)) |							\
		(v & (YF | XF)) | ((r >> 8) & CF) | NF |				\
		((zA ^ r ^ v) & HF) |									\
		((((v ^ zA) & (zA ^ r)) >> 5) & VF);					\
}

/***************************************************************
 * ADD16
 ***************************************************************/
#define ADD16(dst, src)											\
{																\
	u32 r = dst + src;											\
	zF = (zF & (SF | ZF | VF)) |								\
		(((dst ^ r ^ src) >> 8) & HF) |							\
		((r >> 16) & CF) | ((r >> 8) & (YF | XF));				\
	dst = (u16)r;												\
}

/***************************************************************
 * EI
 ***************************************************************/
#define EI														\
{																\
	cpu->ICount -= cc[Opcode];									\
	if (zIFF1 == 0)												\
	{															\
		zIFF1 = zIFF2 = 1;										\
		zR++;													\
		while (GET_BYTE == 0xfb)								\
		{														\
			LOG(("Z80 multiple EI opcodes at %04X\n", zRealPC));\
			cpu->ICount -= cc[Opcode];							\
			zPC++;												\
			zR++;												\
		}														\
		if (cpu->IRQLine)										\
		{														\
			cpu->afterEI = 1;									\
			cpu->ExtraCycles = cpu->ICount;						\
			cpu->ICount = 1;									\
		}														\
	} else zIFF2 = 1;											\
}


/***************************************************************
 for CB prefix
 ***************************************************************/

/***************************************************************
 * RLC  r8
 ***************************************************************/
#define RLC(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x80) ? CF : 0;								\
	v = ((v << 1) | (v >> 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RRC  r8
 ***************************************************************/
#define RRC(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x01) ? CF : 0;								\
	v = ((v >> 1) | (v << 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RL   r8
 ***************************************************************/
#define RL(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x80) ? CF : 0;								\
	v = ((v << 1) | (zF & CF)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RR   r8
 ***************************************************************/
#define RR(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x01) ? CF : 0;								\
	v = ((v >> 1) | (zF << 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SLA  r8
 ***************************************************************/
#define SLA(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x80) ? CF : 0;								\
	v = (v << 1) & 0xff;										\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SRA  r8
 ***************************************************************/
#define SRA(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x01) ? CF : 0;								\
	v = ((v >> 1) | (v & 0x80)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SLL  r8
 ***************************************************************/
#define SLL(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x80) ? CF : 0;								\
	v = ((v << 1) | 0x01) & 0xff;								\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SRL  r8
 ***************************************************************/
#define SRL(r)													\
{																\
	u32 v = r;													\
	u32 c = (v & 0x01) ? CF : 0;								\
	v = (v >> 1) & 0xff;										\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * BIT  bit,r8
 ***************************************************************/
#undef BIT
#define BIT(reg, bit)											\
{																\
	zF = (zF & CF) | HF | SZ_BIT[reg & (1 << bit)];				\
}

/***************************************************************
 * BIT  bit,(IX/Y+o)
 ***************************************************************/

#define BIT_XY(reg, bit)										\
{																\
	zF = (zF & CF) | HF |										\
		 (SZ_BIT[reg & (1<<bit)] & ~(YF | XF)) |				\
		 ((EA >> 8) & (YF | XF));								\
}

/***************************************************************
 * RES  bit,r8
 ***************************************************************/
#define RES(value, bit)											\
{																\
	value &= ~(1 << bit);										\
}

/***************************************************************
 * SET  bit,r8
 ***************************************************************/
#define SET(value, bit)											\
{																\
	value |= (1 << bit);										\
}



/***************************************************************
 for ED prefix
 ***************************************************************/

/***************************************************************
 * Iiiegal (ED prefix)
 ***************************************************************/
#define illegal_ed												\
{																\
	LOG(("Z80 ill. opcode $ed $%02x\n", Opcode));				\
}

/***************************************************************
 * LD   R,A
 ***************************************************************/
#define LD_R_A													\
{																\
	zR = zA;													\
	zR2 = zA & 0x80;											\
}

/***************************************************************
 * LD   A,R
 ***************************************************************/
#define LD_A_R													\
{																\
	zA = (zR & 0x7f) | zR2;										\
	zF = (zF & CF) | SZ[zA] | (zIFF2 << 2);						\
}

/***************************************************************
 * LD   I,A
 ***************************************************************/
#define LD_I_A													\
{																\
	zI = zA;													\
}

/***************************************************************
 * LD   A,I
 ***************************************************************/
#define LD_A_I													\
{																\
	zA = zI;													\
	zF = (zF & CF) | SZ[zA] | (zIFF2 << 2);						\
}

/***************************************************************
 * RRD
 ***************************************************************/
#define RRD														\
{																\
	u8 n;														\
	READ_BYTE(zHL, n)											\
	WRITE_BYTE(zHL, (n >> 4) | (zA << 4))						\
	zA = (zA & 0xf0) | (n & 0x0f);								\
	zF = (zF & CF) | SZP[zA];									\
}

/***************************************************************
 * RLD
 ***************************************************************/
#define RLD														\
{																\
	u8 n;														\
	READ_BYTE(zHL, n)											\
	WRITE_BYTE(zHL, (n << 4) | (zA & 0x0f))						\
	zA = (zA & 0xf0) | (n >> 4);								\
	zF = (zF & CF) | SZP[zA];									\
}

/***************************************************************
 * NEG
 ***************************************************************/
#define NEG														\
{																\
	u32 v = zA;													\
	u32 r = 0 - v;												\
	zA = 0;														\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r;														\
}

/***************************************************************
 * ADC  r16,r16
 ***************************************************************/
#define ADC16(r16)												\
{																\
	u32 r = zHL + r16 + (zF & CF);								\
	zF = (((zHL ^ r ^ r16) >> 8) & HF) |						\
		((r >> 16) & CF) |										\
		((r >> 8) & (SF | YF | XF)) |							\
		((r & 0xffff) ? 0 : ZF) |								\
		(((r16 ^ zHL ^ 0x8000) & (r16 ^ r) & 0x8000) >> 13);	\
	zHL = (u16)r;												\
}

/***************************************************************
 * SBC  r16,r16
 ***************************************************************/
#define SBC16(r16)												\
{																\
	u32 r = zHL - r16 - (zF & CF);								\
	zF = (((zHL ^ r ^ r16) >> 8) & HF) | NF |					\
		((r >> 16) & CF) |										\
		((r >> 8) & (SF | YF | XF)) |							\
		((r & 0xffff) ? 0 : ZF) |								\
		(((r16 ^ zHL) & (zHL ^ r) & 0x8000) >> 13);				\
	zHL = (u16)r;												\
}

/***************************************************************
 * RETN
 ***************************************************************/
#define RETN													\
{																\
	LOG(("Z80 RETN IFF1:%d IFF2:%d\n", zIFF1, zIFF2));			\
	POP_16(PC);													\
	SET_PC(PC);													\
	if (zIFF1 == 0 && zIFF2 == 1)								\
	{															\
		zIFF1 = 1;												\
		if (cpu->IRQLine)										\
		{														\
			LOG(("Z80 RETN takes IRQ\n"));						\
            CHECK_INT											\
		}														\
	}															\
	else zIFF1 = zIFF2;											\
}

/***************************************************************
 * RETI
 ***************************************************************/
#define RETI													\
{																\
	if (cpu->RETI_Callback) cpu->RETI_Callback();				\
	POP_16(PC);													\
	SET_PC(PC);													\
/* according to http://www.msxnet.org/tech/z80-documented.pdf */\
/*  zIFF1 = zIFF2; */											\
}

/***************************************************************
 * LDI
 ***************************************************************/
#define LDI														\
{																\
	u8 io;														\
																\
	READ_BYTE(zHL, io)											\
	WRITE_BYTE(zDE, io)											\
																\
	zF &= SF | ZF | CF;											\
	if ((zA + io) & 0x02) zF |= YF;								\
	if ((zA + io) & 0x08) zF |= XF;								\
																\
	zHL++;														\
	zDE++;														\
	zBC--;														\
																\
	if (zBC) zF |= VF;											\
}

/***************************************************************
 * CPI
 ***************************************************************/
#define CPI														\
{																\
	u8 v, r;													\
																\
	READ_BYTE(zHL, v)											\
	r = zA - v;													\
	zHL++;														\
	zBC--;														\
																\
	zF = (zF & CF) | (SZ[r] & ~(YF | XF)) | 					\
		 ((zA ^ v ^ r) & HF) | NF;								\
	if (zF & HF) r -= 1;										\
	if (r & 0x02) zF |= YF;										\
	if (r & 0x08) zF |= XF;										\
	if (zBC) zF |= VF;											\
}

/***************************************************************
 * INI
 ***************************************************************/
#define INI														\
{																\
	u8 io;														\
	u32 t;														\
																\
	IN(zBC, io)													\
	zB--;														\
	WRITE_BYTE(zHL, io)											\
	zHL++;														\
																\
	zF = SZ[zB];												\
	t = ((u32)(zC - 1) & 0xff) + (u32)io;						\
	if (io & SF) zF |= NF;										\
	if (t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(u8)(t & 0x07) ^ zB] & PF;						\
}

/***************************************************************
 * OUTI
 ***************************************************************/
#define OUTI													\
{																\
	u8 io;														\
	u32 t;														\
																\
	READ_BYTE(zHL, io)											\
	zB--;														\
	OUT(zBC, io)												\
	zHL++;														\
																\
	zF = SZ[zB];												\
	t = (u32)zL + (u32)io;										\
	if (io & SF) zF |= NF;										\
	if (t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(u8)(t & 0x07) ^ zB] & PF;						\
}

/***************************************************************
 * LDD
 ***************************************************************/
#define LDD														\
{																\
	u8 io;														\
																\
	READ_BYTE(zHL, io)											\
	WRITE_BYTE(zDE, io)											\
																\
	zF &= SF | ZF | CF;											\
	if ((zA + io) & 0x02) zF |= YF;								\
	if ((zA + io) & 0x08) zF |= XF;								\
																\
	zHL--;														\
	zDE--;														\
	zBC--;														\
																\
	if (zBC) zF |= VF;											\
}

/***************************************************************
 * CPD
 ***************************************************************/
#define CPD														\
{																\
	u8 v, r;													\
																\
	READ_BYTE(zHL, v)											\
	r = zA - v;													\
	zHL--;														\
	zBC--;														\
																\
	zF = (zF & CF) | (SZ[r] & ~(YF | XF)) | 					\
		 ((zA ^ v ^ r) & HF) | NF;								\
	if (zF & HF) r -= 1;										\
	if (r & 0x02) zF |= YF;										\
	if (r & 0x08) zF |= XF;										\
	if (zBC) zF |= VF;											\
}

/***************************************************************
 * IND
 ***************************************************************/
#define IND														\
{																\
	u8 io;														\
	u32 t;														\
																\
	IN(zBC, io)													\
	zB--;														\
	WRITE_BYTE(zHL, io)											\
	zHL--;														\
																\
	zF = SZ[zB];												\
	t = ((u32)(zC - 1) & 0xff) + (u32)io;						\
	if (io & SF) zF |= NF;										\
	if (t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(u8)(t & 0x07) ^ zB] & PF;						\
}

/***************************************************************
 * OUTD
 ***************************************************************/
#define OUTD													\
{																\
	u8 io;														\
	u32 t;														\
																\
	READ_BYTE(zHL, io)											\
	zB--;														\
	OUT(zBC, io)												\
	zHL--;														\
																\
	zF = SZ[zB];												\
	t = (u32)zL + (u32)io;										\
	if (io & SF) zF |= NF;										\
	if (t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(u8)(t & 0x07) ^ zB] & PF;						\
}

/***************************************************************
 * LDIR
 ***************************************************************/
#define LDIR													\
{																\
	LDI															\
	if (zBC)													\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * CPIR
 ***************************************************************/
#define CPIR													\
{																\
	CPI															\
	if (zBC && !(zF & ZF))										\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * INIR
 ***************************************************************/
#define INIR													\
{																\
	INI															\
	if (zB)														\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * OTIR
 ***************************************************************/
#define OTIR													\
{																\
	OUTI														\
	if (zB)														\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * LDDR
 ***************************************************************/
#define LDDR													\
{																\
	LDD															\
	if (zBC)													\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * CPDR
 ***************************************************************/
#define CPDR													\
{																\
	CPD															\
	if (zBC && !(zF & ZF))										\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * INDR
 ***************************************************************/
#define INDR													\
{																\
	IND															\
	if (zB)														\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}

/***************************************************************
 * OTDR
 ***************************************************************/
#define OTDR													\
{																\
	OUTD														\
	if (zB)														\
	{															\
		zPC -= 2;												\
		NEXT_EX													\
	}															\
}



/***************************************************************
 for DD / FD prefix
 ***************************************************************/

/***************************************************************
 * Calculate the effective addrs EA of an opcode
 ***************************************************************/
#define EAX EA = zIX + FETCH_BYTE_S;
#define EAY EA = zIY + FETCH_BYTE_S;

/***************************************************************
 * Iiiegal (DD / FD prefix)
 ***************************************************************/
#define illegal_xy												\
{																\
	LOG(("Z80 ill. opcode $02x $%02x\n", *(zPC - 1), Opcode));	\
}

#endif /* CZ80_MACRO_H */
